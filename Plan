Plan


Прототип на руби
Актуальная версия на Java

* Чтение с файла
	* Разные форматы
	* Схема

* Создание модели
	* Нормализация
	* Графовая БД
	* Возможно распределенное хранение
	* Дописывание в модель
		* merge моделей
	* дамп

* Классификация
	* Метрики
		* Посмотреть в TiMBL
			* возможные метрики
			* как передавать в метрики общие (глобальные) данные
			* архитектура загрузки данных
		* Добавить в гит репо.
		* Возможно спереть из TiMBL
	* Алгоритм минимизации расстояния
	* Взвешевания всякие
	* PCA для визуализации
	* k-means для увеличения кол-ва вершин.
		* автоматическое назначение новых вершин
		* увеличить качетсво кластеризатора
	* Передалеть k-means в k-medoids (должно быть изи)
		* возможность добавлять произвольную метрику к кластеризатору

* визуализация
	* рисовать все точки прозрачным
	* рисовать линии

Обучение.



* инициализировать граф
	* :init & :end вершины графа.
	* нода -> название
	* вывод -> нода
	* граф
	* вершина -> датасет
		* Датасет:
			* нода -> объекты
			* объект -> свойства

* спарсить строку


Разные режимы работы.



Алгоритм Витерби для метрик

V_{t,k} - стоимость первых t, конец в k.
a_{x,k} - вероятность перехода из x в k
a_{x,k,t} - расстояние, потраченное переходе из x в k


V[0] = 
{
	:init => 0
}

V[1] =
{
	:init => Int, # :init => :init have no path
	:A1 => S.min{ |X| knn(X => A1) + V[0][X] },
	:A2 => S.min{ |X| knn(X => B1) + V[0][X] }
}


Следовать UNIX-way, не загромождать.

Как можно больше всего вынести во внешние тулзы - в том числе и кластеризацию.



Сделать как можно модульнее и настраививаемее



tensors and their applications in graph structured domains

Придумать архитертуру для производительной версии

Учесть возможно разные данные в одной ноде. (как :end и проч.)

Возможность натроения R-дерева на стадии создания модели

Возможность указывания метрик как внешних процедур

